---
name: skill-creator
description: 효과적인 스킬 생성을 위한 가이드. 이 스킬은 사용자가 Claude의 기능을 전문 지식, 워크플로우 또는 도구 통합으로 확장하는 새로운 스킬을 생성하거나 기존 스킬을 업데이트하려고 할 때 사용해야 합니다.
license: 전체 조건은 LICENSE.txt에 있습니다
---

# 스킬 생성기

이 스킬은 효과적인 스킬 생성을 위한 가이드를 제공합니다.

## 스킬 소개

스킬은 전문 지식, 워크플로우, 도구를 제공하여 Claude의 기능을 확장하는 모듈식 자체 완결형 패키지입니다. 특정 도메인이나 작업에 대한 "온보딩 가이드"라고 생각하면 됩니다—스킬은 Claude를 범용 에이전트에서 어떤 모델도 완전히 보유할 수 없는 절차적 지식을 갖춘 전문 에이전트로 변환합니다.

### 스킬이 제공하는 것

1. 전문화된 워크플로우 - 특정 도메인을 위한 다단계 절차
2. 도구 통합 - 특정 파일 형식이나 API 작업을 위한 지침
3. 도메인 전문성 - 회사별 지식, 스키마, 비즈니스 로직
4. 번들 리소스 - 복잡하고 반복적인 작업을 위한 스크립트, 참조 자료, 에셋

## 핵심 원칙

### 간결함이 핵심

컨텍스트 윈도우는 공공재입니다. 스킬은 Claude가 필요로 하는 모든 것과 컨텍스트 윈도우를 공유합니다: 시스템 프롬프트, 대화 기록, 다른 스킬의 메타데이터, 실제 사용자 요청.

**기본 가정: Claude는 이미 매우 똑똑합니다.** Claude가 이미 가지고 있지 않은 컨텍스트만 추가하세요. 각 정보에 대해 질문하세요: "Claude가 정말 이 설명이 필요한가?" 그리고 "이 단락이 토큰 비용을 정당화하는가?"

장황한 설명보다 간결한 예시를 선호하세요.

### 적절한 자유도 설정

작업의 취약성과 가변성에 맞게 구체성 수준을 조정하세요:

**높은 자유도 (텍스트 기반 지침)**: 여러 접근 방식이 유효하거나, 결정이 컨텍스트에 따라 달라지거나, 휴리스틱이 접근 방식을 안내할 때 사용합니다.

**중간 자유도 (매개변수가 있는 의사 코드 또는 스크립트)**: 선호하는 패턴이 존재하거나, 일부 변형이 허용되거나, 구성이 동작에 영향을 미칠 때 사용합니다.

**낮은 자유도 (특정 스크립트, 적은 매개변수)**: 작업이 취약하고 오류가 발생하기 쉽거나, 일관성이 중요하거나, 특정 순서를 따라야 할 때 사용합니다.

Claude가 길을 탐색한다고 생각하세요: 절벽이 있는 좁은 다리는 특정 가드레일이 필요하고(낮은 자유도), 열린 들판은 많은 경로를 허용합니다(높은 자유도).

### 스킬의 구조

모든 스킬은 필수 SKILL.md 파일과 선택적 번들 리소스로 구성됩니다:

```
skill-name/
├── SKILL.md (필수)
│   ├── YAML 프론트매터 메타데이터 (필수)
│   │   ├── name: (필수)
│   │   └── description: (필수)
│   └── 마크다운 지침 (필수)
└── 번들 리소스 (선택)
    ├── scripts/          - 실행 가능한 코드 (Python/Bash 등)
    ├── references/       - 필요에 따라 컨텍스트에 로드되도록 의도된 문서
    └── assets/           - 출력에 사용되는 파일 (템플릿, 아이콘, 폰트 등)
```

#### SKILL.md (필수)

모든 SKILL.md는 다음으로 구성됩니다:

- **프론트매터** (YAML): `name`과 `description` 필드를 포함합니다. 이것은 Claude가 스킬이 언제 사용되는지 결정하기 위해 읽는 유일한 필드이므로, 스킬이 무엇인지, 언제 사용해야 하는지 명확하고 포괄적으로 설명하는 것이 매우 중요합니다.
- **본문** (마크다운): 스킬 사용을 위한 지침과 가이드. 스킬이 트리거된 후에만 로드됩니다(트리거되는 경우).

#### 번들 리소스 (선택)

##### 스크립트 (`scripts/`)

결정론적 신뢰성이 필요하거나 반복적으로 재작성되는 작업을 위한 실행 가능한 코드(Python/Bash 등).

- **포함 시기**: 동일한 코드가 반복적으로 재작성되거나 결정론적 신뢰성이 필요할 때
- **예시**: PDF 회전 작업을 위한 `scripts/rotate_pdf.py`
- **장점**: 토큰 효율적, 결정론적, 컨텍스트에 로드하지 않고 실행 가능
- **참고**: 스크립트는 패치나 환경별 조정을 위해 Claude가 읽어야 할 수도 있습니다

##### 참조 자료 (`references/`)

Claude의 프로세스와 사고에 정보를 제공하기 위해 필요에 따라 컨텍스트에 로드되도록 의도된 문서 및 참조 자료.

- **포함 시기**: Claude가 작업하면서 참조해야 하는 문서의 경우
- **예시**: 재무 스키마용 `references/finance.md`, 회사 NDA 템플릿용 `references/mnda.md`, 회사 정책용 `references/policies.md`, API 사양용 `references/api_docs.md`
- **사용 사례**: 데이터베이스 스키마, API 문서, 도메인 지식, 회사 정책, 상세 워크플로우 가이드
- **장점**: SKILL.md를 간결하게 유지, Claude가 필요하다고 판단할 때만 로드
- **모범 사례**: 파일이 큰 경우(10k 단어 초과), SKILL.md에 grep 검색 패턴을 포함하세요
- **중복 방지**: 정보는 SKILL.md 또는 참조 파일 중 하나에만 있어야 하며, 둘 다에 있으면 안 됩니다. 스킬의 핵심이 아닌 한 상세 정보는 참조 파일을 선호하세요—이렇게 하면 컨텍스트 윈도우를 독차지하지 않으면서 SKILL.md를 간결하게 유지하고 정보를 검색 가능하게 만듭니다. 필수적인 절차 지침과 워크플로우 가이드만 SKILL.md에 유지하고, 상세 참조 자료, 스키마, 예시는 참조 파일로 이동하세요.

##### 에셋 (`assets/`)

컨텍스트에 로드되도록 의도되지 않았지만, Claude가 생성하는 출력 내에서 사용되는 파일.

- **포함 시기**: 스킬이 최종 출력에 사용될 파일이 필요할 때
- **예시**: 브랜드 에셋용 `assets/logo.png`, 파워포인트 템플릿용 `assets/slides.pptx`, HTML/React 보일러플레이트용 `assets/frontend-template/`, 타이포그래피용 `assets/font.ttf`
- **사용 사례**: 템플릿, 이미지, 아이콘, 보일러플레이트 코드, 폰트, 복사되거나 수정되는 샘플 문서
- **장점**: 출력 리소스를 문서와 분리, Claude가 컨텍스트에 로드하지 않고 파일을 사용할 수 있게 함

#### 스킬에 포함하지 말아야 할 것

스킬은 기능을 직접 지원하는 필수 파일만 포함해야 합니다. 다음을 포함한 불필요한 문서나 보조 파일을 생성하지 마세요:

- README.md
- INSTALLATION_GUIDE.md
- QUICK_REFERENCE.md
- CHANGELOG.md
- 등

스킬은 AI 에이전트가 당면한 작업을 수행하는 데 필요한 정보만 포함해야 합니다. 생성 과정에 대한 보조 컨텍스트, 설정 및 테스트 절차, 사용자 대면 문서 등을 포함해서는 안 됩니다. 추가 문서 파일을 만드는 것은 혼란만 가중시킵니다.

### 점진적 공개 설계 원칙

스킬은 컨텍스트를 효율적으로 관리하기 위해 3단계 로딩 시스템을 사용합니다:

1. **메타데이터 (이름 + 설명)** - 항상 컨텍스트에 있음 (~100 단어)
2. **SKILL.md 본문** - 스킬이 트리거될 때 (<5k 단어)
3. **번들 리소스** - Claude가 필요할 때 (스크립트는 컨텍스트 윈도우에 읽지 않고 실행 가능하므로 무제한)

#### 점진적 공개 패턴

컨텍스트 비대화를 최소화하기 위해 SKILL.md 본문을 필수 사항으로 유지하고 500줄 미만으로 유지하세요. 이 한도에 근접하면 콘텐츠를 별도의 파일로 분할하세요. 다른 파일로 콘텐츠를 분할할 때, SKILL.md에서 참조하고 언제 읽어야 하는지 명확하게 설명하는 것이 매우 중요합니다. 이렇게 하면 스킬을 읽는 사람이 해당 파일이 존재하고 언제 사용해야 하는지 알 수 있습니다.

**핵심 원칙:** 스킬이 여러 변형, 프레임워크 또는 옵션을 지원할 때, 핵심 워크플로우와 선택 가이드만 SKILL.md에 유지하세요. 변형별 세부 사항(패턴, 예시, 구성)은 별도의 참조 파일로 이동하세요.

**패턴 1: 참조가 있는 고수준 가이드**

```markdown
# PDF 처리

## 빠른 시작

pdfplumber로 텍스트 추출:
[코드 예시]

## 고급 기능

- **양식 작성**: 전체 가이드는 [FORMS.md](FORMS.md) 참조
- **API 참조**: 모든 메서드는 [REFERENCE.md](REFERENCE.md) 참조
- **예시**: 일반적인 패턴은 [EXAMPLES.md](EXAMPLES.md) 참조
```

Claude는 필요할 때만 FORMS.md, REFERENCE.md 또는 EXAMPLES.md를 로드합니다.

**패턴 2: 도메인별 구성**

여러 도메인이 있는 스킬의 경우, 관련 없는 컨텍스트 로딩을 피하기 위해 도메인별로 콘텐츠를 구성하세요:

```
bigquery-skill/
├── SKILL.md (개요 및 탐색)
└── reference/
    ├── finance.md (매출, 청구 지표)
    ├── sales.md (기회, 파이프라인)
    ├── product.md (API 사용, 기능)
    └── marketing.md (캠페인, 어트리뷰션)
```

사용자가 영업 지표에 대해 질문하면, Claude는 sales.md만 읽습니다.

마찬가지로, 여러 프레임워크나 변형을 지원하는 스킬의 경우 변형별로 구성하세요:

```
cloud-deploy/
├── SKILL.md (워크플로우 + 공급자 선택)
└── references/
    ├── aws.md (AWS 배포 패턴)
    ├── gcp.md (GCP 배포 패턴)
    └── azure.md (Azure 배포 패턴)
```

사용자가 AWS를 선택하면, Claude는 aws.md만 읽습니다.

**패턴 3: 조건부 세부 사항**

기본 콘텐츠를 표시하고, 고급 콘텐츠를 링크하세요:

```markdown
# DOCX 처리

## 문서 생성

새 문서에는 docx-js를 사용하세요. [DOCX-JS.md](DOCX-JS.md) 참조.

## 문서 편집

간단한 편집의 경우 XML을 직접 수정하세요.

**변경 내용 추적의 경우**: [REDLINING.md](REDLINING.md) 참조
**OOXML 세부 사항의 경우**: [OOXML.md](OOXML.md) 참조
```

Claude는 사용자가 해당 기능을 필요로 할 때만 REDLINING.md 또는 OOXML.md를 읽습니다.

**중요 지침:**

- **깊이 중첩된 참조 피하기** - SKILL.md에서 한 단계 깊이의 참조만 유지하세요. 모든 참조 파일은 SKILL.md에서 직접 링크해야 합니다.
- **긴 참조 파일 구조화** - 100줄 이상의 파일의 경우 상단에 목차를 포함하여 Claude가 미리보기 시 전체 범위를 볼 수 있도록 하세요.

## 스킬 생성 프로세스

스킬 생성은 다음 단계를 포함합니다:

1. 구체적인 예시로 스킬 이해하기
2. 재사용 가능한 스킬 콘텐츠 계획하기 (스크립트, 참조, 에셋)
3. 스킬 초기화하기 (init_skill.py 실행)
4. 스킬 편집하기 (리소스 구현 및 SKILL.md 작성)
5. 스킬 패키징하기 (package_skill.py 실행)
6. 실제 사용 기반으로 반복하기

이 단계를 순서대로 따르되, 해당되지 않는 명확한 이유가 있는 경우에만 건너뛰세요.

### 1단계: 구체적인 예시로 스킬 이해하기

스킬의 사용 패턴이 이미 명확하게 이해된 경우에만 이 단계를 건너뛰세요. 기존 스킬로 작업할 때도 이 단계는 여전히 가치가 있습니다.

효과적인 스킬을 만들려면 스킬이 어떻게 사용될지에 대한 구체적인 예시를 명확히 이해해야 합니다. 이 이해는 직접적인 사용자 예시 또는 사용자 피드백으로 검증된 생성된 예시에서 올 수 있습니다.

예를 들어, 이미지 편집기 스킬을 구축할 때 관련 질문은 다음과 같습니다:

- "이미지 편집기 스킬이 어떤 기능을 지원해야 하나요? 편집, 회전, 그 외 다른 것?"
- "이 스킬이 어떻게 사용될지 몇 가지 예시를 들어주실 수 있나요?"
- "사용자가 '이 이미지에서 적목 현상을 제거해주세요' 또는 '이 이미지를 회전해주세요'와 같은 것을 요청할 것으로 상상됩니다. 이 스킬이 사용될 수 있는 다른 방법이 있나요?"
- "이 스킬을 트리거해야 하는 사용자의 말은 무엇인가요?"

사용자를 압도하지 않기 위해 한 메시지에 너무 많은 질문을 하지 마세요. 가장 중요한 질문부터 시작하고 더 나은 효과를 위해 필요에 따라 후속 질문하세요.

스킬이 지원해야 하는 기능에 대한 명확한 감각이 있을 때 이 단계를 마무리하세요.

### 2단계: 재사용 가능한 스킬 콘텐츠 계획하기

구체적인 예시를 효과적인 스킬로 전환하려면 다음을 통해 각 예시를 분석하세요:

1. 처음부터 예시를 어떻게 실행할지 고려하기
2. 이러한 워크플로우를 반복적으로 실행할 때 어떤 스크립트, 참조, 에셋이 도움이 될지 식별하기

예시: "이 PDF를 회전하는 것을 도와주세요"와 같은 쿼리를 처리하기 위해 `pdf-editor` 스킬을 구축할 때 분석 결과:

1. PDF를 회전하려면 매번 동일한 코드를 다시 작성해야 함
2. 스킬에 저장할 `scripts/rotate_pdf.py` 스크립트가 도움이 될 것임

예시: "할 일 앱을 만들어주세요" 또는 "걸음 수를 추적하는 대시보드를 만들어주세요"와 같은 쿼리를 위한 `frontend-webapp-builder` 스킬을 설계할 때 분석 결과:

1. 프론트엔드 웹앱을 작성하려면 매번 동일한 보일러플레이트 HTML/React가 필요함
2. 보일러플레이트 HTML/React 프로젝트 파일을 포함하는 `assets/hello-world/` 템플릿이 스킬에 저장하는 데 도움이 될 것임

예시: "오늘 몇 명의 사용자가 로그인했나요?"와 같은 쿼리를 처리하기 위해 `big-query` 스킬을 구축할 때 분석 결과:

1. BigQuery를 쿼리하려면 매번 테이블 스키마와 관계를 다시 발견해야 함
2. 테이블 스키마를 문서화하는 `references/schema.md` 파일이 스킬에 저장하는 데 도움이 될 것임

스킬의 콘텐츠를 확립하려면 각 구체적인 예시를 분석하여 포함할 재사용 가능한 리소스 목록을 만드세요: 스크립트, 참조, 에셋.

### 3단계: 스킬 초기화하기

이 시점에서 실제로 스킬을 생성할 시간입니다.

개발 중인 스킬이 이미 존재하고 반복이나 패키징이 필요한 경우에만 이 단계를 건너뛰세요. 이 경우 다음 단계로 계속하세요.

처음부터 새 스킬을 만들 때는 항상 `init_skill.py` 스크립트를 실행하세요. 이 스크립트는 스킬에 필요한 모든 것을 자동으로 포함하는 새 템플릿 스킬 디렉토리를 편리하게 생성하여 스킬 생성 프로세스를 훨씬 더 효율적이고 신뢰할 수 있게 만듭니다.

사용법:

```bash
scripts/init_skill.py <skill-name> --path <output-directory>
```

스크립트는:

- 지정된 경로에 스킬 디렉토리를 생성합니다
- 적절한 프론트매터와 TODO 플레이스홀더가 있는 SKILL.md 템플릿을 생성합니다
- 예시 리소스 디렉토리를 생성합니다: `scripts/`, `references/`, `assets/`
- 사용자 정의하거나 삭제할 수 있는 각 디렉토리에 예시 파일을 추가합니다

초기화 후, 생성된 SKILL.md와 예시 파일을 필요에 따라 사용자 정의하거나 제거하세요.

### 4단계: 스킬 편집하기

(새로 생성된 또는 기존의) 스킬을 편집할 때, 스킬은 다른 Claude 인스턴스가 사용하도록 만들어진다는 것을 기억하세요. Claude에게 유익하고 명확하지 않은 정보를 포함하세요. 어떤 절차적 지식, 도메인별 세부 사항 또는 재사용 가능한 에셋이 다른 Claude 인스턴스가 이러한 작업을 더 효과적으로 실행하는 데 도움이 될지 고려하세요.

#### 검증된 디자인 패턴 학습하기

스킬의 필요에 따라 다음 유용한 가이드를 참조하세요:

- **다단계 프로세스**: 순차적 워크플로우와 조건부 로직은 references/workflows.md 참조
- **특정 출력 형식 또는 품질 표준**: 템플릿과 예시 패턴은 references/output-patterns.md 참조

이 파일들은 효과적인 스킬 디자인을 위한 확립된 모범 사례를 포함합니다.

#### 재사용 가능한 스킬 콘텐츠부터 시작하기

구현을 시작하려면 위에서 식별한 재사용 가능한 리소스부터 시작하세요: `scripts/`, `references/`, `assets/` 파일. 이 단계는 사용자 입력이 필요할 수 있습니다. 예를 들어, `brand-guidelines` 스킬을 구현할 때 사용자는 `assets/`에 저장할 브랜드 에셋이나 템플릿, 또는 `references/`에 저장할 문서를 제공해야 할 수 있습니다.

추가된 스크립트는 실제로 실행하여 버그가 없고 출력이 예상과 일치하는지 확인해야 합니다. 유사한 스크립트가 많은 경우, 모든 스크립트가 작동한다는 확신을 갖기 위해 대표적인 샘플만 테스트하면서 완료 시간과 균형을 맞추세요.

스킬에 필요하지 않은 예시 파일과 디렉토리는 삭제해야 합니다. 초기화 스크립트는 구조를 보여주기 위해 `scripts/`, `references/`, `assets/`에 예시 파일을 생성하지만, 대부분의 스킬은 모두 필요하지 않습니다.

#### SKILL.md 업데이트하기

**작성 지침:** 항상 명령형/부정사 형태를 사용하세요.

##### 프론트매터

`name`과 `description`으로 YAML 프론트매터를 작성하세요:

- `name`: 스킬 이름
- `description`: 이것은 스킬의 주요 트리거 메커니즘이며, Claude가 스킬을 언제 사용해야 하는지 이해하는 데 도움이 됩니다.
  - 스킬이 무엇을 하는지와 언제 사용해야 하는지에 대한 구체적인 트리거/컨텍스트를 모두 포함하세요.
  - 모든 "언제 사용해야 하는지" 정보를 여기에 포함하세요 - 본문에는 포함하지 마세요. 본문은 트리거 후에만 로드되므로, 본문의 "이 스킬을 사용해야 할 때" 섹션은 Claude에게 도움이 되지 않습니다.
  - `docx` 스킬에 대한 설명 예시: "변경 내용 추적, 주석, 서식 보존 및 텍스트 추출을 지원하는 포괄적인 문서 생성, 편집 및 분석. Claude가 다음을 위해 전문 문서(.docx 파일)로 작업해야 할 때 사용: (1) 새 문서 생성, (2) 콘텐츠 수정 또는 편집, (3) 변경 내용 추적 작업, (4) 주석 추가, 또는 기타 문서 작업"

YAML 프론트매터에 다른 필드를 포함하지 마세요.

##### 본문

스킬과 번들 리소스 사용을 위한 지침을 작성하세요.

### 5단계: 스킬 패키징하기

스킬 개발이 완료되면 사용자와 공유할 배포 가능한 .skill 파일로 패키징해야 합니다. 패키징 프로세스는 모든 요구 사항을 충족하는지 확인하기 위해 스킬을 먼저 자동으로 검증합니다:

```bash
scripts/package_skill.py <path/to/skill-folder>
```

선택적 출력 디렉토리 지정:

```bash
scripts/package_skill.py <path/to/skill-folder> ./dist
```

패키징 스크립트는:

1. 스킬을 **자동으로 검증**하여 다음을 확인합니다:

   - YAML 프론트매터 형식과 필수 필드
   - 스킬 명명 규칙과 디렉토리 구조
   - 설명의 완전성과 품질
   - 파일 구성과 리소스 참조

2. 검증이 통과하면 스킬을 **패키징**하여, 스킬 이름을 딴 .skill 파일(예: `my-skill.skill`)을 생성합니다. 이 파일은 모든 파일을 포함하고 배포를 위한 적절한 디렉토리 구조를 유지합니다. .skill 파일은 .skill 확장자를 가진 zip 파일입니다.

검증이 실패하면 스크립트는 오류를 보고하고 패키지를 생성하지 않고 종료합니다. 검증 오류를 수정하고 패키징 명령을 다시 실행하세요.

### 6단계: 반복하기

스킬을 테스트한 후 사용자가 개선을 요청할 수 있습니다. 종종 이것은 스킬을 사용한 직후에 발생하며, 스킬이 어떻게 수행되었는지에 대한 신선한 컨텍스트가 있습니다.

**반복 워크플로우:**

1. 실제 작업에서 스킬 사용하기
2. 어려움이나 비효율성 발견하기
3. SKILL.md 또는 번들 리소스를 어떻게 업데이트해야 하는지 식별하기
4. 변경 사항 구현하고 다시 테스트하기
